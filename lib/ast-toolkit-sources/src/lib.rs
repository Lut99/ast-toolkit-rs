//  LIB.rs
//    by Lut99
//
//  Description:
//!   Highly specialized datastructure for loading source texts and parsing
//!   them with references, while mutating the structure itself to add more
//!   texts.
//

// Modules
mod key;

// Imports
use std::collections::HashMap;
use std::fmt::Debug;
use std::hash::{BuildHasher, Hash, RandomState};
use std::marker::PhantomData;

use key::Key;


/***** LIBRARY *****/
/// Defines a list that can be populated while we're already (read-only) borrowing its elements.
///
/// This is a useful datastructure for ASTs as we tend to want to parse a file, understand its
/// dependencies, and then read and parse its dependencies. This requires mutable access to the
/// collection _while_ being able to refer to its elements long-lastig (to prevent unnecessary
/// borrows).
///
/// This is achieved by some pointer magic internally. The main crux is that this structure is
/// append-only, and the internal sources cannot be mutated; once added, they are added, and will
/// remain in-place and untouched until another mutable borrow is acquired (which forces you to
/// drop any existing references first). E.g., dropping the struct.
pub struct Sources<I, S, H = RandomState> {
    /// The list of 'em all.
    data: HashMap<Key<I>, *const S, H>,
}

// Constructors
impl<I, S> Sources<I, S> {
    /// Constructor for creating an empty Sources list.
    ///
    /// # Returns
    /// An empty Source list. To populate it, call [`Sources::load()`].
    #[inline]
    pub fn new() -> Self { Self { data: HashMap::new() } }

    /// Constructor for creating an empty Sources list with a certain capacity.
    ///
    /// # Arguments
    /// - `capacity`: A (minimum!) number of sources that this list should be able to load before
    ///   the collection needs to be re-allocated. Note that, by design, the sources themselves are
    ///   allocated externally, and _never_ need re-allocation. Only the collection of pointers to
    ///   them is affected by this.
    ///
    /// # Returns
    /// An empty Source list that can store at least `capacity` sources before the collection needs
    /// re-allocation. To populate it, call [`Sources::load()`].
    #[inline]
    pub fn with_capacity(capacity: usize) -> Self { Self { data: HashMap::with_capacity(capacity) } }
}
impl<I, S, H> Sources<I, S, H> {
    /// Constructor for creating an empty Sources list with a specific hasher.
    ///
    /// # Arguments
    /// - `hasher`: Some `H`asher to initialize the internal HashMap with.
    ///
    /// # Returns
    /// An empty Source list. To populate it, call [`Sources::load()`].
    #[inline]
    pub fn with_hasher(hasher: H) -> Self { Self { data: HashMap::with_hasher(hasher) } }

    /// Constructor for creating an empty Sources list with a certain hasher and with a certain capacity.
    ///
    /// # Arguments
    /// - `capacity`: A (minimum!) number of sources that this list should be able to load before
    ///   the collection needs to be re-allocated. Note that, by design, the sources themselves are
    ///   allocated externally, and _never_ need re-allocation. Only the collection of pointers to
    ///   them is affected by this.
    /// - `hasher`: Some `H`asher to initialize the internal HashMap with.
    ///
    /// # Returns
    /// An empty Source list that can store at least `capacity` sources before the collection needs
    /// re-allocation. To populate it, call [`Sources::load()`].
    #[inline]
    pub fn with_capacity_and_hasher(capacity: usize, hasher: H) -> Self { Self { data: HashMap::with_capacity_and_hasher(capacity, hasher) } }
}

// Destructors
impl<I, S, H> Drop for Sources<I, S, H> {
    fn drop(&mut self) {
        for (id, source) in self.data.drain() {
            // SAFETY: We can take ownership of both elements because we are, at this point, sure
            // that no external references exist. Any generated by us has a lifetime to this
            // sources list, so, logically, if we have a mutable reference then they must all be
            // gone. Hence, we can remove the memory without a worry in the world.
            drop(unsafe { Box::from_raw(id.into_ptr() as *mut I) });
            // SAFETY: See above.
            drop(unsafe { Box::from_raw(source as *mut S) });
        }
    }
}

// Sources
impl<I, S, H> Sources<I, S, H> {
    /// The only way of mutating the `Sources` list.
    ///
    /// This allows you to add new sources through the [`SourcesAccess::insert()`]-method _while_
    /// generating nodes that reference `'s`elf. I.e., it allows you to load sources, store them,
    /// parse them while taking references, and then add more sources if yours have dependencies.
    ///
    /// See [`SourcesAccess`] for more information.
    ///
    /// # Arguments
    /// - `access`: A closure that uses a [`SourcesAccess`] to interact with the collection. It
    ///   returns the resulting nodes, or whatever else you want to return.
    ///
    /// # Returns
    /// This function simply returns whatever `access` does.
    pub fn load<'s, T>(&'s mut self, access: impl for<'a> FnOnce(SourcesAccess<'a, 's, I, S, H>) -> T) -> T {
        let data: SourcesAccess<'_, 's, I, S, H> = SourcesAccess(&mut self.data, PhantomData);
        access(data)
    }
}
impl<I: Eq + Hash, S, H: BuildHasher> Sources<I, S, H> {
    /// Provides access to one of the `S`ources.
    ///
    /// Only read-access is provided, because of potential lingering read-only references on your
    /// side.
    ///
    /// # Arguments
    /// - `id`: Some `I`dentifier by which we recognize the source to get.
    ///
    /// # Returns
    /// A `&'s S`ource if we found one for the given `id`, or else [`None`].
    #[inline]
    pub fn get<'s>(&'s self, id: &I) -> Option<&'s S> {
        // SAFETY: It's OK to get a pointer and assume it's valid, as `I` will exist for the
        // duration of this function.
        let key = unsafe { Key::new(id as *const I) };
        self.data.get(&key).map(|source| {
            // SAFETY: We can assume the `source` is valid and exists because we have never
            // deallocated it or mutated it; i.e., we behaved as if there are already read-only
            // pointers to it (which there probably are).
            unsafe { &**source }
        })
    }

    /// Checks if a source with the given `id` exists.
    ///
    /// # Returns
    /// True if it's been [`SourcesAccess::insert()`]ed before, or false otherwise.
    #[inline]
    pub fn contains_key(&self, id: &I) -> bool {
        // SAFETY: It's OK to get a pointer and assume it's valid, as `I` will exist for the
        // duration of this function.
        self.data.contains_key(&unsafe { Key::new(id as *const I) })
    }
}
impl<I, S, H> Sources<I, S, H> {
    /// Returns the number of sources currently in the list.
    ///
    /// # Returns
    /// A [`usize`] encoding this number.
    #[inline]
    pub fn len(&self) -> usize { self.data.len() }

    /// Returns whether there are _any_ sources in the list.
    ///
    /// # Returns
    /// True if [`Self::len() == 0`](Sources::len()), or false otherwise.
    #[inline]
    pub fn is_empty(&self) -> bool { self.data.is_empty() }
}



/// Provides access to the _collection_ of the Sources.
///
/// This is the magic struct. By explicitly decoupling access to the collection (`'a`) and the
/// elements (`'s`) we can conveniently use lifetime semantics for the underlying map while keeping
/// (read-only) borrows to the elements.
///
/// This struct is only obtainable through [`Sources::load()`]'s closure. You should _not_ leak it
/// outside of that in any way, that will result into a BFM ("Big Fucking Mess").
pub struct SourcesAccess<'a, 's, I, S, H>(&'a mut HashMap<Key<I>, *const S, H>, PhantomData<&'s ()>);

// Collection
impl<'a, 's, I: Debug + Eq + Hash, S, H: BuildHasher> SourcesAccess<'a, 's, I, S, H> {
    /// Inserts a new `S`ource into the collection.
    ///
    /// Use the returned `I` and `S` with `'s` lifetimes (that of the original [`Sources`]) to
    /// parse your AST node. You are guaranteed that the lifetime remains valid, i.e., the source
    /// text is never mutated or moved as long as you hold that reference.
    ///
    /// For this reason, this function **cannot overwrite sources.** It will panic if you try. Use
    /// [`SourcesAccess::contains_key()`] to test beforehand if it's safe to do so.
    ///
    /// # Arguments
    /// - `id`: The `I`dentifier of the source that we use to look it up.
    /// - `source`: The `S`ource to actually store.
    ///
    /// # Returns
    /// A `&'s S` that you can use to parse and understand the added source.
    ///
    /// # Panics
    /// This function itself may panic if there already was a source with `id`. Note that the given
    /// `id` and `source` are deallocated properly before it is raised (but anything given before
    /// _will_ be leaked, still).
    #[track_caller]
    pub fn insert(&mut self, id: I, source: S) -> (&'s I, &'s S) {
        // Put the bad boys on the heap and make a `Key` out of `id`
        let (id, source): (*const I, *const S) = (Box::into_raw(Box::new(id)), Box::into_raw(Box::new(source)));
        // SAFETY: This function is unsafe because we need to assert that `id` is valid for its
        // entire lifetime. Luckily for us, we promise that: we will not move or deallocate `id`
        // anywhere from this point forward (only its pointer itself).
        let key: Key<I> = unsafe { Key::new(id) };

        // Assert it doesn't exist yet
        if self.0.contains_key(&key) {
            // SAFETY: While on the heap, we haven't actually touched either, so we can easily get
            // them back (for debugging & dropping).
            let (id, _): (Box<I>, Box<S>) = (unsafe { Box::from_raw(id as *mut I) }, unsafe { Box::from_raw(source as *mut S) });
            panic!("Cannot add source ID {id:?} to a Sources that already contains it");
        }

        // Add them to the internal storage. From this point onwards, we must promise that they are
        // never moved or invalidated!
        // SAFETY: We acknowledge that we clone `key` here, so that the property that `id` must
        // exist must continue to be upheld also for the clone (which it will; we won't touch it
        // anyway until we drop `Sources`, at which point Rust's lifetime semantics ensure that
        // there is no reference to them anymore).
        self.0.insert(unsafe { key.duplicate() }, source);
        // SAFETY: We just added the elements, so this get cannot fail.
        let (id, source): (&Key<I>, &*const S) = unsafe { self.0.get_key_value(&key).unwrap_unchecked() };

        // Now for the big trick
        // SAFETY: We get references valid for `'s` to the pointers due to the nefarious fact that
        // we are religiously preserving the property that WE will never move or invalidate the
        // memory behind the pointers _as long as_ there's references to `'s` out there, and THE
        // USER can never do so by virtue of getting read-only pointers.
        (unsafe { &*id.as_ptr() }, unsafe { &**source })
    }
}
impl<'a, 's, I: Eq + Hash, S, H: BuildHasher> SourcesAccess<'a, 's, I, S, H> {
    /// Provides access to one of the `S`ources.
    ///
    /// Only read-access is provided, because of potential lingering read-only references on your
    /// side.
    ///
    /// # Arguments
    /// - `id`: Some `I`dentifier by which we recognize the source to get.
    ///
    /// # Returns
    /// A `&'s S`ource if we found one for the given `id`, or else [`None`].
    #[inline]
    pub fn get(&self, id: &I) -> Option<&'s S> {
        // SAFETY: It's OK to get a pointer and assume it's valid, as `I` will exist for the
        // duration of this function.
        let key = unsafe { Key::new(id as *const I) };
        self.0.get(&key).map(|source| {
            // SAFETY: We can assume the `source` is valid and exists because we have never
            // deallocated it or mutated it; i.e., we behaved as if there are already read-only
            // pointers to it (which there probably are).
            unsafe { &**source }
        })
    }

    /// Checks if a source with the given `id` exists.
    ///
    /// # Returns
    /// True if it's been [`SourcesAccess::insert()`]ed before, or false otherwise.
    #[inline]
    pub fn contains_key(&self, id: &I) -> bool {
        // SAFETY: It's OK to get a pointer and assume it's valid, as `I` will exist for the
        // duration of this function.
        self.0.contains_key(&unsafe { Key::new(id as *const I) })
    }
}
impl<'a, 's, I, S, H> SourcesAccess<'a, 's, I, S, H> {
    /// Returns the number of sources currently in the list.
    ///
    /// # Returns
    /// A [`usize`] encoding this number.
    #[inline]
    pub fn len(&self) -> usize { self.0.len() }

    /// Returns whether there are _any_ sources in the list.
    ///
    /// # Returns
    /// True if [`Self::len() == 0`](SourcesAccess::len()), or false otherwise.
    #[inline]
    pub fn is_empty(&self) -> bool { self.0.is_empty() }
}





/***** TESTS *****/
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_sources() {
        // Not exactly a thorough test, but using:
        // ```
        // valgrind --leak-check=full ./target/debug/deps/ast_toolkit_sources*
        // ```
        // reasonably confident that this simple usage works :)

        // Let's build an object
        let mut sources = Sources::<String, Vec<u8>>::new();
        let node: Vec<&Vec<u8>> = sources.load(|mut access| {
            // Add some source
            let (_, src1) = access.insert("hello".into(), b"Hello, world!".into());
            let (_, src2) = access.insert("goodbye".into(), b"Goodbye, world!".into());
            vec![src1, src2]
        });
        assert_eq!(node[0], b"Hello, world!");
        assert_eq!(node[1], b"Goodbye, world!");
    }
}
