//  LIB.rs
//    by Lut99
//
//  Created:
//    14 Mar 2024, 08:37:24
//  Last edited:
//    20 Mar 2025, 12:09:03
//  Auto updated?
//    Yes
//
//  Description:
//!   The sun is coming out, the birds are tweeting... It's that time of
//!   the year again! Lut99 makes another re-code of `nom`!
//!   
//!   Provides a parser-combinator framework heavily inspired by
//!   [nom](https://github.com/rust-bakery/nom), except that it gives up a
//!   little bit of performance over a more human-friendly debug experience.
//

// Declare submodules
pub mod branch;
pub mod bytes;
// #[cfg(feature = "c")]
// pub mod c;
pub mod combinator;
// pub mod debug;
pub mod error;
// pub mod multi;
// #[cfg(feature = "derive")]
// pub mod procedural;
pub mod result;
pub mod sequence;
pub mod span;
pub mod utf8;

// Imports
use std::borrow::Cow;
use std::error::Error;
use std::fmt::{Debug, Display, Formatter, Result as FResult};

// Re-exports
#[cfg(feature = "derive")]
pub use ast_toolkit_snack_derive::comb;
pub use ast_toolkit_span::{Span, Spanning};
use span::Parsable;


/***** CONSTANTS *****/
/// Defines the indent size for every level in [`Expects`] formatting.
#[allow(unused)]
const EXPECTS_INDENT_SIZE: usize = 4;





/***** LIBRARY *****/
/// A trait implemented by errors that are returned by snack [`Combinator`]s.
pub trait ParseError<S: Clone>: Debug + Error + Spanning<S> {}
impl<T: Error + Spanning<S>, S: Clone> ParseError<S> for T {}



/// A trait implemented by [`Expects::Formatter`]s.
///
/// This trait actually produces expect-strings.
pub trait ExpectsFormatter: Debug + Display {
    /// Formats the thing that this Expects expected as input.
    ///
    /// The string written should be something along the lines of filling in `XXX` in:
    /// ```plain
    /// Expected XXX.
    /// ```
    ///
    /// # Arguments
    /// - `f`: Some [`Formatter`] to write to.
    /// - `indent`: If this formatter writes newlines, they should be indented by this amount.
    ///
    /// # Errors
    /// This function should only error if it failed to write to the given `f`ormatter.
    fn expects_fmt(&self, f: &mut Formatter, indent: usize) -> FResult;
}

// Default impls for pointer-like types
impl<'a, T: ?Sized + ExpectsFormatter> ExpectsFormatter for &'a T {
    #[inline]
    fn expects_fmt(&self, f: &mut Formatter, indent: usize) -> FResult { (**self).expects_fmt(f, indent) }
}
impl<T: ?Sized + ExpectsFormatter> ExpectsFormatter for Box<T> {
    #[inline]
    fn expects_fmt(&self, f: &mut Formatter, indent: usize) -> FResult { (**self).expects_fmt(f, indent) }
}

// Default impls for string-like types
impl ExpectsFormatter for str {
    #[inline]
    fn expects_fmt(&self, f: &mut Formatter, _indent: usize) -> FResult {
        // If it begins with `Expected`, cut that off
        if self.starts_with("Expected ") { <str as Display>::fmt(&self[9..], f) } else { <str as Display>::fmt(self, f) }
    }
}
impl<'a> ExpectsFormatter for Cow<'a, str> {
    #[inline]
    fn expects_fmt(&self, f: &mut Formatter, _indent: usize) -> FResult {
        // If it begins with `Expected`, cut that off
        if self.starts_with("Expected ") { <str as Display>::fmt(&self[9..], f) } else { <str as Display>::fmt(self, f) }
    }
}
impl ExpectsFormatter for String {
    #[inline]
    fn expects_fmt(&self, f: &mut Formatter, _indent: usize) -> FResult {
        // If it begins with `Expected`, cut that off
        if self.starts_with("Expected ") { <str as Display>::fmt(&self[9..], f) } else { <str as Display>::fmt(self, f) }
    }
}



/// A trait that unifies all snack combinators.
///
/// A combinator is a stateful parser that parses a small part of an AST. By composing them, one
/// can create modular parsers that are efficient and logical to reason over. Moreover, because
/// the combinator tree tends to represent an AST, friendly error messages can be generated by
/// expressing what each combinator expects.
///
/// This is the standard combinator trait. For combinators that do multiple other combinators in
/// succession (e.g., a tuple), this trait encodes conjuction, i.e., all of the parsers must
/// succeed and their results are all returned. By contrast, the [`BranchingCombinator`]-trait
/// encodes disjunction, i.e., the parsers are tried in-order and the first to succeed becomes the
/// result of parsing. In that case, all errors are collected instead.
///
/// # Generics
/// - `'t`: Some lifetime of something upon which the combinator depends. Typically, this is used
///   to make the [`Combinator::ExpectsFormatter`] depend on it too and efficiently delay
///   serialization of the expects-string until the last moment.
/// - `F`: Some from-string that any input [`Span`] carries.
/// - `S`: Some source-string that any input [`Span`] carries. This is what is effectively parsed.
pub trait Combinator<'t, S: Clone + Parsable> {
    /// The type that is in charge of generating the expects-string.
    type ExpectsFormatter: ExpectsFormatter;
    /// The output type for this Combinator.
    type Output;
    /// Some error type that is thrown when the combinator fails but in a recoverable way.
    ///
    /// This means that any wrapping [`alt()`](branch::alt()) should still try another branch.
    type Recoverable: ParseError<S>;
    /// Some error type that is thrown when the combinator fails unrecoverably.
    ///
    /// This means that there is no point for any wrapping [`alt()`](branch::alt()) to still try
    /// another branch.
    type Fatal: ParseError<S>;


    /// Returns some [`ExpectsFormatter`] that can write a string describing what
    /// input this combinator expects.
    ///
    /// It typically implements [`Display`] to show a fully-fledged error string.
    ///
    /// # Returns
    /// A [`Combinator::ExpectsFormatter`] that can be used to create the expects string.
    fn expects(&self) -> Self::ExpectsFormatter;

    /// Runs the combinator on a [`Span`] of input.
    ///
    /// # Arguments
    /// - `input`: The input to parse.
    ///
    /// # Returns
    /// A pair of the remaining input left unparsed (as a [`Span`]) and something of type
    /// [`Combinator::Output`] that encodes the result of this parser.
    ///
    /// # Errors
    /// The parse function should error if it failed to parse anything. It has three ways of doing
    /// so:
    /// - It can emit a [`SnackError::Recoverable`](crate::result::SnackError::Recoverable), which
    ///   returns something of [`Combinator::Recoverable`] and encodes that any wrapping
    ///   [`alt()`](branch::alt()) should still try another branch;
    /// - It can emit a [`SnackError::Fatal`](crate::result::SnackError::Fatal), which returns
    ///   something of [`Combinator::Fatal`] and encodes that there is no point for any wrapping
    ///   [`alt()`](branch::alt()) to still try another branch.
    /// - It can emit a [`SnackError::NotEnough`](crate::result::SnackError::NotEnough), which
    ///   encodes that the input *may* become parsable if additional input is given. This is useful
    ///   when streaming the input from e.g. stdin or a socket, and one retrieves input in chunks
    ///   that aren't necessarily valid.
    ///
    /// # Examples
    /// For examples, look at any of the combinators that are shipped with the Snack library.
    fn parse(&mut self, input: Span<S>) -> crate::result::Result<Self::Output, Self::Recoverable, Self::Fatal, S>;
}

// Default impl for pointer-like types
impl<'a, 't, S: Clone + Parsable, T: Combinator<'t, S>> Combinator<'t, S> for &'a mut T {
    type ExpectsFormatter = T::ExpectsFormatter;
    type Output = T::Output;
    type Recoverable = T::Recoverable;
    type Fatal = T::Fatal;

    #[inline]
    fn expects(&self) -> Self::ExpectsFormatter { <T as Combinator<'t, S>>::expects(self) }

    #[inline]
    fn parse(&mut self, input: Span<S>) -> crate::result::Result<Self::Output, Self::Recoverable, Self::Fatal, S> {
        <T as Combinator<'t, S>>::parse(self, input)
    }
}



/// A trait that unifies snack combinators that are trying different parsing paths. This in
/// contrast to the [`Combinator`], which assumes that combinators are doing all paths
/// sequentially (see it for more information).
///
/// You typically don't have to interact with this trait; it is hidden behind
/// [`alt()`](branch::alt()). However, you can implement it manually for your combinators in order
/// to extend the parser combinator library with powerful schemes for trying different ways of
/// parsing.
///
/// # Generics
/// - `'t`: Some lifetime of something upon which the combinator depends. Typically, this is used
///   to make the [`Combinator::ExpectsFormatter`] depend on it too and efficiently delay
///   serialization of the expects-string until the last moment.
/// - `F`: Some from-string that any input [`Span`] carries.
/// - `S`: Some source-string that any input [`Span`] carries. This is what is effectively parsed.
pub trait BranchingCombinator<'t, S: Clone + Parsable> {
    /// The type that is in charge of generating the expects-string.
    type ExpectsFormatter: ExpectsFormatter;
    /// The output type for all paths of this Combinator.
    type Output;
    /// Some error type that is thrown when a combinator fails but in a recoverable way.
    ///
    /// This means that any wrapping [`alt()`](branch::alt()) should still try another branch.
    type Recoverable: ParseError<S>;
    /// Some error type that is thrown when a combinator fails unrecoverably.
    ///
    /// This means that there is no point for any wrapping [`alt()`](branch::alt()) to still try
    /// another branch.
    type Fatal: ParseError<S>;


    /// Returns some [`ExpectsFormatter`] that can write a string describing what
    /// input this combinator expects.
    ///
    /// It typically implements [`Display`] to show a fully-fledged error string.
    ///
    /// # Returns
    /// A [`BranchingCombinator::ExpectsFormatter`] that can be used to create the expects string.
    fn expects(&self) -> Self::ExpectsFormatter;

    /// Runs the combinator on a [`Span`] of input.
    ///
    /// # Arguments
    /// - `input`: The input to parse.
    ///
    /// # Returns
    /// A pair of the remaining input left unparsed (as a [`Span`]) and something of type
    /// [`BranchingCombinator::Output`] that encodes the result of this parser.
    ///
    /// # Errors
    /// The parse function should error if it failed to parse anything. It has three ways of doing
    /// so:
    /// - It can emit a [`SnackError::Recoverable`](crate::result::SnackError::Recoverable), which
    ///   returns something of [`BranchingCombinator::Recoverable`] and encodes that any wrapping
    ///   [`alt()`](branch::alt()) should still try another branch;
    /// - It can emit a [`SnackError::Fatal`](crate::result::SnackError::Fatal), which returns
    ///   something of [`BranchingCombinator::Fatal`] and encodes that there is no point for any
    ///   wrapping [`alt()`](branch::alt()) to still try another branch.
    /// - It can emit a [`SnackError::NotEnough`](crate::result::SnackError::NotEnough), which
    ///   encodes that the input *may* become parsable if additional input is given. This is useful
    ///   when streaming the input from e.g. stdin or a socket, and one retrieves input in chunks
    ///   that aren't necessarily valid.
    ///
    /// # Examples
    /// For examples, look at any of the combinators that are shipped with the Snack library.
    fn parse(&mut self, input: Span<S>) -> crate::result::Result<Self::Output, Self::Recoverable, Self::Fatal, S>;
}

// Default impl for pointer-like types
impl<'a, 't, S: Clone + Parsable, T: BranchingCombinator<'t, S>> BranchingCombinator<'t, S> for &'a mut T {
    type ExpectsFormatter = T::ExpectsFormatter;
    type Output = T::Output;
    type Recoverable = T::Recoverable;
    type Fatal = T::Fatal;

    #[inline]
    fn expects(&self) -> Self::ExpectsFormatter { <T as BranchingCombinator<'t, S>>::expects(self) }

    #[inline]
    fn parse(&mut self, input: Span<S>) -> crate::result::Result<Self::Output, Self::Recoverable, Self::Fatal, S> {
        <T as BranchingCombinator<'t, S>>::parse(self, input)
    }
}
